/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['assertion.js']) {
  _$jscoverage['assertion.js'] = [];
  _$jscoverage['assertion.js'][48] = 0;
  _$jscoverage['assertion.js'][57] = 0;
  _$jscoverage['assertion.js'][68] = 0;
  _$jscoverage['assertion.js'][69] = 0;
  _$jscoverage['assertion.js'][70] = 0;
  _$jscoverage['assertion.js'][71] = 0;
  _$jscoverage['assertion.js'][87] = 0;
  _$jscoverage['assertion.js'][101] = 0;
  _$jscoverage['assertion.js'][102] = 0;
  _$jscoverage['assertion.js'][103] = 0;
  _$jscoverage['assertion.js'][106] = 0;
  _$jscoverage['assertion.js'][107] = 0;
  _$jscoverage['assertion.js'][125] = 0;
  _$jscoverage['assertion.js'][127] = 0;
  _$jscoverage['assertion.js'][141] = 0;
  _$jscoverage['assertion.js'][143] = 0;
  _$jscoverage['assertion.js'][157] = 0;
  _$jscoverage['assertion.js'][159] = 0;
  _$jscoverage['assertion.js'][174] = 0;
  _$jscoverage['assertion.js'][176] = 0;
  _$jscoverage['assertion.js'][177] = 0;
  _$jscoverage['assertion.js'][191] = 0;
  _$jscoverage['assertion.js'][193] = 0;
  _$jscoverage['assertion.js'][206] = 0;
  _$jscoverage['assertion.js'][208] = 0;
  _$jscoverage['assertion.js'][222] = 0;
  _$jscoverage['assertion.js'][224] = 0;
  _$jscoverage['assertion.js'][238] = 0;
  _$jscoverage['assertion.js'][240] = 0;
  _$jscoverage['assertion.js'][254] = 0;
  _$jscoverage['assertion.js'][256] = 0;
  _$jscoverage['assertion.js'][270] = 0;
  _$jscoverage['assertion.js'][272] = 0;
  _$jscoverage['assertion.js'][273] = 0;
  _$jscoverage['assertion.js'][292] = 0;
  _$jscoverage['assertion.js'][294] = 0;
  _$jscoverage['assertion.js'][299] = 0;
  _$jscoverage['assertion.js'][313] = 0;
  _$jscoverage['assertion.js'][315] = 0;
  _$jscoverage['assertion.js'][322] = 0;
  _$jscoverage['assertion.js'][336] = 0;
  _$jscoverage['assertion.js'][338] = 0;
  _$jscoverage['assertion.js'][345] = 0;
  _$jscoverage['assertion.js'][364] = 0;
  _$jscoverage['assertion.js'][366] = 0;
  _$jscoverage['assertion.js'][372] = 0;
  _$jscoverage['assertion.js'][388] = 0;
  _$jscoverage['assertion.js'][390] = 0;
  _$jscoverage['assertion.js'][392] = 0;
  _$jscoverage['assertion.js'][393] = 0;
  _$jscoverage['assertion.js'][394] = 0;
  _$jscoverage['assertion.js'][395] = 0;
  _$jscoverage['assertion.js'][398] = 0;
  _$jscoverage['assertion.js'][403] = 0;
  _$jscoverage['assertion.js'][421] = 0;
  _$jscoverage['assertion.js'][423] = 0;
  _$jscoverage['assertion.js'][431] = 0;
  _$jscoverage['assertion.js'][448] = 0;
  _$jscoverage['assertion.js'][449] = 0;
  _$jscoverage['assertion.js'][455] = 0;
  _$jscoverage['assertion.js'][470] = 0;
  _$jscoverage['assertion.js'][471] = 0;
  _$jscoverage['assertion.js'][477] = 0;
  _$jscoverage['assertion.js'][492] = 0;
  _$jscoverage['assertion.js'][493] = 0;
  _$jscoverage['assertion.js'][498] = 0;
  _$jscoverage['assertion.js'][513] = 0;
  _$jscoverage['assertion.js'][514] = 0;
  _$jscoverage['assertion.js'][519] = 0;
  _$jscoverage['assertion.js'][535] = 0;
  _$jscoverage['assertion.js'][536] = 0;
  _$jscoverage['assertion.js'][538] = 0;
  _$jscoverage['assertion.js'][543] = 0;
  _$jscoverage['assertion.js'][558] = 0;
  _$jscoverage['assertion.js'][559] = 0;
  _$jscoverage['assertion.js'][561] = 0;
  _$jscoverage['assertion.js'][569] = 0;
  _$jscoverage['assertion.js'][588] = 0;
  _$jscoverage['assertion.js'][589] = 0;
  _$jscoverage['assertion.js'][590] = 0;
  _$jscoverage['assertion.js'][595] = 0;
  _$jscoverage['assertion.js'][615] = 0;
  _$jscoverage['assertion.js'][616] = 0;
  _$jscoverage['assertion.js'][617] = 0;
  _$jscoverage['assertion.js'][618] = 0;
  _$jscoverage['assertion.js'][621] = 0;
  _$jscoverage['assertion.js'][627] = 0;
  _$jscoverage['assertion.js'][628] = 0;
  _$jscoverage['assertion.js'][638] = 0;
  _$jscoverage['assertion.js'][639] = 0;
  _$jscoverage['assertion.js'][655] = 0;
  _$jscoverage['assertion.js'][656] = 0;
  _$jscoverage['assertion.js'][660] = 0;
  _$jscoverage['assertion.js'][677] = 0;
  _$jscoverage['assertion.js'][678] = 0;
  _$jscoverage['assertion.js'][679] = 0;
  _$jscoverage['assertion.js'][681] = 0;
  _$jscoverage['assertion.js'][689] = 0;
  _$jscoverage['assertion.js'][704] = 0;
  _$jscoverage['assertion.js'][705] = 0;
  _$jscoverage['assertion.js'][710] = 0;
  _$jscoverage['assertion.js'][725] = 0;
  _$jscoverage['assertion.js'][726] = 0;
  _$jscoverage['assertion.js'][731] = 0;
  _$jscoverage['assertion.js'][746] = 0;
  _$jscoverage['assertion.js'][747] = 0;
  _$jscoverage['assertion.js'][749] = 0;
  _$jscoverage['assertion.js'][754] = 0;
  _$jscoverage['assertion.js'][768] = 0;
  _$jscoverage['assertion.js'][770] = 0;
  _$jscoverage['assertion.js'][771] = 0;
  _$jscoverage['assertion.js'][790] = 0;
  _$jscoverage['assertion.js'][791] = 0;
  _$jscoverage['assertion.js'][794] = 0;
  _$jscoverage['assertion.js'][798] = 0;
  _$jscoverage['assertion.js'][800] = 0;
  _$jscoverage['assertion.js'][804] = 0;
  _$jscoverage['assertion.js'][805] = 0;
  _$jscoverage['assertion.js'][809] = 0;
  _$jscoverage['assertion.js'][810] = 0;
  _$jscoverage['assertion.js'][814] = 0;
  _$jscoverage['assertion.js'][815] = 0;
  _$jscoverage['assertion.js'][816] = 0;
  _$jscoverage['assertion.js'][818] = 0;
  _$jscoverage['assertion.js'][819] = 0;
  _$jscoverage['assertion.js'][821] = 0;
  _$jscoverage['assertion.js'][825] = 0;
  _$jscoverage['assertion.js'][828] = 0;
  _$jscoverage['assertion.js'][831] = 0;
  _$jscoverage['assertion.js'][839] = 0;
  _$jscoverage['assertion.js'][869] = 0;
  _$jscoverage['assertion.js'][870] = 0;
  _$jscoverage['assertion.js'][872] = 0;
  _$jscoverage['assertion.js'][874] = 0;
  _$jscoverage['assertion.js'][875] = 0;
  _$jscoverage['assertion.js'][876] = 0;
  _$jscoverage['assertion.js'][877] = 0;
  _$jscoverage['assertion.js'][878] = 0;
  _$jscoverage['assertion.js'][879] = 0;
  _$jscoverage['assertion.js'][882] = 0;
  _$jscoverage['assertion.js'][883] = 0;
  _$jscoverage['assertion.js'][886] = 0;
  _$jscoverage['assertion.js'][887] = 0;
  _$jscoverage['assertion.js'][891] = 0;
  _$jscoverage['assertion.js'][894] = 0;
  _$jscoverage['assertion.js'][895] = 0;
  _$jscoverage['assertion.js'][900] = 0;
  _$jscoverage['assertion.js'][901] = 0;
  _$jscoverage['assertion.js'][902] = 0;
  _$jscoverage['assertion.js'][907] = 0;
  _$jscoverage['assertion.js'][909] = 0;
  _$jscoverage['assertion.js'][913] = 0;
  _$jscoverage['assertion.js'][915] = 0;
  _$jscoverage['assertion.js'][920] = 0;
  _$jscoverage['assertion.js'][936] = 0;
  _$jscoverage['assertion.js'][937] = 0;
  _$jscoverage['assertion.js'][941] = 0;
  _$jscoverage['assertion.js'][949] = 0;
  _$jscoverage['assertion.js'][964] = 0;
  _$jscoverage['assertion.js'][965] = 0;
  _$jscoverage['assertion.js'][973] = 0;
  _$jscoverage['assertion.js'][989] = 0;
  _$jscoverage['assertion.js'][990] = 0;
  _$jscoverage['assertion.js'][995] = 0;
  _$jscoverage['assertion.js'][1002] = 0;
  _$jscoverage['assertion.js'][1003] = 0;
  _$jscoverage['assertion.js'][1004] = 0;
}
_$jscoverage['assertion.js'][48]++;
var AssertionError = require("./error"), eql = require("./utils/eql"), toString = Object.prototype.toString, inspect = require("./utils/inspect");
_$jscoverage['assertion.js'][57]++;
module.exports = Assertion;
_$jscoverage['assertion.js'][68]++;
function Assertion(obj, msg, stack) {
  _$jscoverage['assertion.js'][69]++;
  this.ssfi = stack || arguments.callee;
  _$jscoverage['assertion.js'][70]++;
  this.obj = obj;
  _$jscoverage['assertion.js'][71]++;
  this.msg = msg;
}
_$jscoverage['assertion.js'][87]++;
Assertion.includeStack = false;
_$jscoverage['assertion.js'][101]++;
Assertion.prototype.assert = (function (expr, msg, negateMsg, expected, actual) {
  _$jscoverage['assertion.js'][102]++;
  actual = actual || this.obj;
  _$jscoverage['assertion.js'][103]++;
  var msg = (this.negate? negateMsg: msg), ok = this.negate? ! expr: expr;
  _$jscoverage['assertion.js'][106]++;
  if (! ok) {
    _$jscoverage['assertion.js'][107]++;
    throw new AssertionError({message: this.msg? this.msg + ": " + msg: msg, actual: actual, expected: expected, stackStartFunction: Assertion.includeStack? this.assert: this.ssfi});
  }
});
_$jscoverage['assertion.js'][125]++;
Object.defineProperty(Assertion.prototype, "inspect", {get: (function () {
  _$jscoverage['assertion.js'][127]++;
  return inspect(this.obj);
}), configurable: true});
_$jscoverage['assertion.js'][141]++;
Object.defineProperty(Assertion.prototype, "to", {get: (function () {
  _$jscoverage['assertion.js'][143]++;
  return this;
}), configurable: true});
_$jscoverage['assertion.js'][157]++;
Object.defineProperty(Assertion.prototype, "be", {get: (function () {
  _$jscoverage['assertion.js'][159]++;
  return this;
}), configurable: true});
_$jscoverage['assertion.js'][174]++;
Object.defineProperty(Assertion.prototype, "been", {get: (function () {
  _$jscoverage['assertion.js'][176]++;
  this.tense = "past";
  _$jscoverage['assertion.js'][177]++;
  return this;
}), configurable: true});
_$jscoverage['assertion.js'][191]++;
Object.defineProperty(Assertion.prototype, "an", {get: (function () {
  _$jscoverage['assertion.js'][193]++;
  return this;
}), configurable: true});
_$jscoverage['assertion.js'][206]++;
Object.defineProperty(Assertion.prototype, "is", {get: (function () {
  _$jscoverage['assertion.js'][208]++;
  return this;
}), configurable: true});
_$jscoverage['assertion.js'][222]++;
Object.defineProperty(Assertion.prototype, "and", {get: (function () {
  _$jscoverage['assertion.js'][224]++;
  return this;
}), configurable: true});
_$jscoverage['assertion.js'][238]++;
Object.defineProperty(Assertion.prototype, "have", {get: (function () {
  _$jscoverage['assertion.js'][240]++;
  return this;
}), configurable: true});
_$jscoverage['assertion.js'][254]++;
Object.defineProperty(Assertion.prototype, "with", {get: (function () {
  _$jscoverage['assertion.js'][256]++;
  return this;
}), configurable: true});
_$jscoverage['assertion.js'][270]++;
Object.defineProperty(Assertion.prototype, "not", {get: (function () {
  _$jscoverage['assertion.js'][272]++;
  this.negate = true;
  _$jscoverage['assertion.js'][273]++;
  return this;
}), configurable: true});
_$jscoverage['assertion.js'][292]++;
Object.defineProperty(Assertion.prototype, "ok", {get: (function () {
  _$jscoverage['assertion.js'][294]++;
  this.assert(this.obj, "expected " + this.inspect + " to be truthy", "expected " + this.inspect + " to be falsy");
  _$jscoverage['assertion.js'][299]++;
  return this;
}), configurable: true});
_$jscoverage['assertion.js'][313]++;
Object.defineProperty(Assertion.prototype, "true", {get: (function () {
  _$jscoverage['assertion.js'][315]++;
  this.assert(true === this.obj, "expected " + this.inspect + " to be true", "expected " + this.inspect + " to be false", this.negate? false: true);
  _$jscoverage['assertion.js'][322]++;
  return this;
}), configurable: true});
_$jscoverage['assertion.js'][336]++;
Object.defineProperty(Assertion.prototype, "false", {get: (function () {
  _$jscoverage['assertion.js'][338]++;
  this.assert(false === this.obj, "expected " + this.inspect + " to be false", "expected " + this.inspect + " to be true", this.negate? true: false);
  _$jscoverage['assertion.js'][345]++;
  return this;
}), configurable: true});
_$jscoverage['assertion.js'][364]++;
Object.defineProperty(Assertion.prototype, "exist", {get: (function () {
  _$jscoverage['assertion.js'][366]++;
  this.assert(null != this.obj, "expected " + this.inspect + " to exist", "expected " + this.inspect + " to not exist");
  _$jscoverage['assertion.js'][372]++;
  return this;
}), configurable: true});
_$jscoverage['assertion.js'][388]++;
Object.defineProperty(Assertion.prototype, "empty", {get: (function () {
  _$jscoverage['assertion.js'][390]++;
  var expected = this.obj;
  _$jscoverage['assertion.js'][392]++;
  if (Array.isArray(this.obj)) {
    _$jscoverage['assertion.js'][393]++;
    expected = this.obj.length;
  }
  else {
    _$jscoverage['assertion.js'][394]++;
    if (typeof this.obj === "object") {
      _$jscoverage['assertion.js'][395]++;
      expected = Object.keys(this.obj).length;
    }
  }
  _$jscoverage['assertion.js'][398]++;
  this.assert(! expected, "expected " + this.inspect + " to be empty", "expected " + this.inspect + " not to be empty");
  _$jscoverage['assertion.js'][403]++;
  return this;
}), configurable: true});
_$jscoverage['assertion.js'][421]++;
Object.defineProperty(Assertion.prototype, "arguments", {get: (function () {
  _$jscoverage['assertion.js'][423]++;
  this.assert("[object Arguments]" == Object.prototype.toString.call(this.obj), "expected " + this.inspect + " to be arguments", "expected " + this.inspect + " to not be arguments", "[object Arguments]", Object.prototype.toString.call(this.obj));
  _$jscoverage['assertion.js'][431]++;
  return this;
}), configurable: true});
_$jscoverage['assertion.js'][448]++;
Assertion.prototype.equal = (function (val) {
  _$jscoverage['assertion.js'][449]++;
  this.assert(val === this.obj, "expected " + this.inspect + " to equal " + inspect(val), "expected " + this.inspect + " to not equal " + inspect(val), val);
  _$jscoverage['assertion.js'][455]++;
  return this;
});
_$jscoverage['assertion.js'][470]++;
Assertion.prototype.eql = (function (obj) {
  _$jscoverage['assertion.js'][471]++;
  this.assert(eql(obj, this.obj), "expected " + this.inspect + " to equal " + inspect(obj), "expected " + this.inspect + " to not equal " + inspect(obj), obj);
  _$jscoverage['assertion.js'][477]++;
  return this;
});
_$jscoverage['assertion.js'][492]++;
Assertion.prototype.above = (function (val) {
  _$jscoverage['assertion.js'][493]++;
  this.assert(this.obj > val, "expected " + this.inspect + " to be above " + val, "expected " + this.inspect + " to be below " + val);
  _$jscoverage['assertion.js'][498]++;
  return this;
});
_$jscoverage['assertion.js'][513]++;
Assertion.prototype.below = (function (val) {
  _$jscoverage['assertion.js'][514]++;
  this.assert(this.obj < val, "expected " + this.inspect + " to be below " + val, "expected " + this.inspect + " to be above " + val);
  _$jscoverage['assertion.js'][519]++;
  return this;
});
_$jscoverage['assertion.js'][535]++;
Assertion.prototype.within = (function (start, finish) {
  _$jscoverage['assertion.js'][536]++;
  var range = start + ".." + finish;
  _$jscoverage['assertion.js'][538]++;
  this.assert(this.obj >= start && this.obj <= finish, "expected " + this.inspect + " to be within " + range, "expected " + this.inspect + " to not be within " + range);
  _$jscoverage['assertion.js'][543]++;
  return this;
});
_$jscoverage['assertion.js'][558]++;
Assertion.prototype.a = (function (type) {
  _$jscoverage['assertion.js'][559]++;
  var klass = type.charAt(0).toUpperCase() + type.slice(1);
  _$jscoverage['assertion.js'][561]++;
  this.assert("[object " + klass + "]" === toString.call(this.obj), "expected " + this.inspect + " to be a " + type, "expected " + this.inspect + " not to be a " + type, "[object " + klass + "]", toString.call(this.obj));
  _$jscoverage['assertion.js'][569]++;
  return this;
});
_$jscoverage['assertion.js'][588]++;
Assertion.prototype["instanceof"] = (function (constructor) {
  _$jscoverage['assertion.js'][589]++;
  var name = constructor.name;
  _$jscoverage['assertion.js'][590]++;
  this.assert(this.obj instanceof constructor, "expected " + this.inspect + " to be an instance of " + name, "expected " + this.inspect + " to not be an instance of " + name);
  _$jscoverage['assertion.js'][595]++;
  return this;
});
_$jscoverage['assertion.js'][615]++;
Assertion.prototype.property = (function (name, val) {
  _$jscoverage['assertion.js'][616]++;
  if (this.negate && undefined !== val) {
    _$jscoverage['assertion.js'][617]++;
    if (undefined === this.obj[name]) {
      _$jscoverage['assertion.js'][618]++;
      throw new Error(this.inspect + " has no property " + inspect(name));
    }
  }
  else {
    _$jscoverage['assertion.js'][621]++;
    this.assert(undefined !== this.obj[name], "expected " + this.inspect + " to have a property " + inspect(name), "expected " + this.inspect + " to not have property " + inspect(name));
  }
  _$jscoverage['assertion.js'][627]++;
  if (undefined !== val) {
    _$jscoverage['assertion.js'][628]++;
    this.assert(val === this.obj[name], "expected " + this.inspect + " to have a property " + inspect(name) + " of " + inspect(val) + ", but got " + inspect(this.obj[name]), "expected " + this.inspect + " to not have a property " + inspect(name) + " of " + inspect(val), val, this.obj[val]);
  }
  _$jscoverage['assertion.js'][638]++;
  this.obj = this.obj[name];
  _$jscoverage['assertion.js'][639]++;
  return this;
});
_$jscoverage['assertion.js'][655]++;
Assertion.prototype.ownProperty = (function (name) {
  _$jscoverage['assertion.js'][656]++;
  this.assert(this.obj.hasOwnProperty(name), "expected " + this.inspect + " to have own property " + inspect(name), "expected " + this.inspect + " to not have own property " + inspect(name));
  _$jscoverage['assertion.js'][660]++;
  return this;
});
_$jscoverage['assertion.js'][677]++;
Assertion.prototype.length = (function (n) {
  _$jscoverage['assertion.js'][678]++;
  new Assertion(this.obj).to.have.property("length");
  _$jscoverage['assertion.js'][679]++;
  var len = this.obj.length;
  _$jscoverage['assertion.js'][681]++;
  this.assert(len == n, "expected " + this.inspect + " to have a length of " + n + " but got " + len, "expected " + this.inspect + " to not have a length of " + len, n, len);
  _$jscoverage['assertion.js'][689]++;
  return this;
});
_$jscoverage['assertion.js'][704]++;
Assertion.prototype.match = (function (re) {
  _$jscoverage['assertion.js'][705]++;
  this.assert(re.exec(this.obj), "expected " + this.inspect + " to match " + re, "expected " + this.inspect + " not to match " + re);
  _$jscoverage['assertion.js'][710]++;
  return this;
});
_$jscoverage['assertion.js'][725]++;
Assertion.prototype.include = (function (obj) {
  _$jscoverage['assertion.js'][726]++;
  this.assert(~ this.obj.indexOf(obj), "expected " + this.inspect + " to include " + inspect(obj), "expected " + this.inspect + " to not include " + inspect(obj));
  _$jscoverage['assertion.js'][731]++;
  return this;
});
_$jscoverage['assertion.js'][746]++;
Assertion.prototype.string = (function (str) {
  _$jscoverage['assertion.js'][747]++;
  new Assertion(this.obj).is.a("string");
  _$jscoverage['assertion.js'][749]++;
  this.assert(~ this.obj.indexOf(str), "expected " + this.inspect + " to contain " + inspect(str), "expected " + this.inspect + " to not contain " + inspect(str));
  _$jscoverage['assertion.js'][754]++;
  return this;
});
_$jscoverage['assertion.js'][768]++;
Object.defineProperty(Assertion.prototype, "contain", {get: (function () {
  _$jscoverage['assertion.js'][770]++;
  this.contains = true;
  _$jscoverage['assertion.js'][771]++;
  return this;
}), configurable: true});
_$jscoverage['assertion.js'][790]++;
Assertion.prototype.keys = (function (keys) {
  _$jscoverage['assertion.js'][791]++;
  var str, ok = true;
  _$jscoverage['assertion.js'][794]++;
  keys = keys instanceof Array? keys: Array.prototype.slice.call(arguments);
  _$jscoverage['assertion.js'][798]++;
  if (! keys.length) {
    _$jscoverage['assertion.js'][798]++;
    throw new Error("keys required");
  }
  _$jscoverage['assertion.js'][800]++;
  var actual = Object.keys(this.obj), len = keys.length;
  _$jscoverage['assertion.js'][804]++;
  ok = keys.every((function (key) {
  _$jscoverage['assertion.js'][805]++;
  return ~ actual.indexOf(key);
}));
  _$jscoverage['assertion.js'][809]++;
  if (! this.negate && ! this.contains) {
    _$jscoverage['assertion.js'][810]++;
    ok = ok && keys.length == actual.length;
  }
  _$jscoverage['assertion.js'][814]++;
  if (len > 1) {
    _$jscoverage['assertion.js'][815]++;
    keys = keys.map((function (key) {
  _$jscoverage['assertion.js'][816]++;
  return inspect(key);
}));
    _$jscoverage['assertion.js'][818]++;
    var last = keys.pop();
    _$jscoverage['assertion.js'][819]++;
    str = keys.join(", ") + ", and " + last;
  }
  else {
    _$jscoverage['assertion.js'][821]++;
    str = inspect(keys[0]);
  }
  _$jscoverage['assertion.js'][825]++;
  str = (len > 1? "keys ": "key ") + str;
  _$jscoverage['assertion.js'][828]++;
  str = (this.contains? "contain ": "have ") + str;
  _$jscoverage['assertion.js'][831]++;
  this.assert(ok, "expected " + this.inspect + " to " + str, "expected " + this.inspect + " to not " + str, keys, Object.keys(this.obj));
  _$jscoverage['assertion.js'][839]++;
  return this;
});
_$jscoverage['assertion.js'][869]++;
Assertion.prototype["throw"] = (function (constructor, msg) {
  _$jscoverage['assertion.js'][870]++;
  new Assertion(this.obj).is.a("function");
  _$jscoverage['assertion.js'][872]++;
  var thrown = false;
  _$jscoverage['assertion.js'][874]++;
  if (arguments.length === 0) {
    _$jscoverage['assertion.js'][875]++;
    msg = null;
    _$jscoverage['assertion.js'][876]++;
    constructor = null;
  }
  else {
    _$jscoverage['assertion.js'][877]++;
    if (constructor && (constructor instanceof RegExp || "string" === typeof constructor)) {
      _$jscoverage['assertion.js'][878]++;
      msg = constructor;
      _$jscoverage['assertion.js'][879]++;
      constructor = null;
    }
  }
  _$jscoverage['assertion.js'][882]++;
  try {
    _$jscoverage['assertion.js'][883]++;
    this.obj();
  }
  catch (err) {
    _$jscoverage['assertion.js'][886]++;
    if (constructor && "function" === typeof constructor) {
      _$jscoverage['assertion.js'][887]++;
      this.assert(err instanceof constructor && err.name == constructor.name, "expected " + this.inspect + " to throw " + constructor.name + " but a " + err.name + " was thrown", "expected " + this.inspect + " to not throw " + constructor.name);
      _$jscoverage['assertion.js'][891]++;
      if (! msg) {
        _$jscoverage['assertion.js'][891]++;
        return this;
      }
    }
    _$jscoverage['assertion.js'][894]++;
    if (err.message && msg && msg instanceof RegExp) {
      _$jscoverage['assertion.js'][895]++;
      this.assert(msg.exec(err.message), "expected " + this.inspect + " to throw error matching " + msg + " but got " + inspect(err.message), "expected " + this.inspect + " to throw error not matching " + msg);
      _$jscoverage['assertion.js'][900]++;
      return this;
    }
    else {
      _$jscoverage['assertion.js'][901]++;
      if (err.message && msg && "string" === typeof msg) {
        _$jscoverage['assertion.js'][902]++;
        this.assert(~ err.message.indexOf(msg), "expected " + this.inspect + " to throw error including " + inspect(msg) + " but got " + inspect(err.message), "expected " + this.inspect + " to throw error not including " + inspect(msg));
        _$jscoverage['assertion.js'][907]++;
        return this;
      }
      else {
        _$jscoverage['assertion.js'][909]++;
        thrown = true;
      }
    }
  }
  _$jscoverage['assertion.js'][913]++;
  var name = (constructor? constructor.name: "an error");
  _$jscoverage['assertion.js'][915]++;
  this.assert(thrown === true, "expected " + this.inspect + " to throw " + name, "expected " + this.inspect + " to not throw " + name);
  _$jscoverage['assertion.js'][920]++;
  return this;
});
_$jscoverage['assertion.js'][936]++;
Assertion.prototype.respondTo = (function (method) {
  _$jscoverage['assertion.js'][937]++;
  var context = ("function" === typeof this.obj)? this.obj.prototype[method]: this.obj[method];
  _$jscoverage['assertion.js'][941]++;
  this.assert("function" === typeof context, "expected " + this.inspect + " to respond to " + inspect(method), "expected " + this.inspect + " to not respond to " + inspect(method), "function", typeof context);
  _$jscoverage['assertion.js'][949]++;
  return this;
});
_$jscoverage['assertion.js'][964]++;
Assertion.prototype.satisfy = (function (matcher) {
  _$jscoverage['assertion.js'][965]++;
  this.assert(matcher(this.obj), "expected " + this.inspect + " to satisfy " + inspect(matcher), "expected " + this.inspect + " to not satisfy" + inspect(matcher), this.negate? false: true, matcher(this.obj));
  _$jscoverage['assertion.js'][973]++;
  return this;
});
_$jscoverage['assertion.js'][989]++;
Assertion.prototype.closeTo = (function (expected, delta) {
  _$jscoverage['assertion.js'][990]++;
  this.assert((this.obj - delta === expected) || (this.obj + delta === expected), "expected " + this.inspect + " to be close to " + expected + " +/- " + delta, "expected " + this.inspect + " not to be close to " + expected + " +/- " + delta);
  _$jscoverage['assertion.js'][995]++;
  return this;
});
_$jscoverage['assertion.js'][1002]++;
(function alias(name, as) {
  _$jscoverage['assertion.js'][1003]++;
  Assertion.prototype[as] = Assertion.prototype[name];
  _$jscoverage['assertion.js'][1004]++;
  return alias;
})("length", "lengthOf")("keys", "key")("ownProperty", "haveOwnProperty")("above", "greaterThan")("below", "lessThan")("throw", "throws")("throw", "Throw")("instanceof", "instanceOf");
_$jscoverage['assertion.js'].source = ["/*!"," * chai"," * Copyright(c) 2011 Jake Luer &lt;jake@alogicalparadox.com&gt;"," * MIT Licensed"," *"," * Primarily a refactor of: should.js"," * https://github.com/visionmedia/should.js"," * Copyright(c) 2011 TJ Holowaychuk &lt;tj@vision-media.ca&gt;"," * MIT Licensed"," */","","/**"," * ### BDD Style Introduction"," *"," * The BDD style is exposed through `expect` or `should` interfaces. In both"," * scenarios, you chain together natural language assertions."," *"," *      // expect"," *      var expect = require('chai').expect;"," *      expect(foo).to.equal('bar');"," *"," *      // should"," *      var should = require('chai').should();"," *      foo.should.equal('bar');"," *"," * #### Differences"," *"," * The `expect` interface provides a function as a starting point for chaining"," * your language assertions. It works on node.js and in all browsers."," *"," * The `should` interface extends `Object.prototype` to provide a single getter as"," * the starting point for your language assertions. It works on node.js and in"," * all browsers except Internet Explorer."," *"," * #### Configuration"," *"," * By default, Chai does not show stack traces upon an AssertionError. This can"," * be changed by modifying the `includeStack` parameter for chai.Assertion. For example:"," *"," *      var chai = require('chai');"," *      chai.Assertion.includeStack = true; // defaults to false"," */","","/*!"," * Module dependencies."," */","","var AssertionError = require('./error')","  , eql = require('./utils/eql')","  , toString = Object.prototype.toString","  , inspect = require('./utils/inspect');","","/*!"," * Module export."," */","","module.exports = Assertion;","","","/*!"," * # Assertion Constructor"," *"," * Creates object for chaining."," *"," * @api private"," */","","function Assertion (obj, msg, stack) {","  this.ssfi = stack || arguments.callee;","  this.obj = obj;","  this.msg = msg;","}","","/*!","  * ## Assertion.includeStack","  * , toString = Object.prototype.toString","  *","  * User configurable property, influences whether stack trace","  * is included in Assertion error message. Default of false","  * suppresses stack trace in the error message","  *","  *     Assertion.includeStack = true;  // enable stack on error","  *","  * @api public","  */","","Assertion.includeStack = false;","","/*!"," * # .assert(expression, message, negateMessage)"," *"," * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass."," *"," * @name assert"," * @param {Philosophical} expression to be tested"," * @param {String} message to display if fails"," * @param {String} negatedMessage to display if negated expression fails"," * @api private"," */","","Assertion.prototype.assert = function (expr, msg, negateMsg, expected, actual) {","  actual = actual || this.obj;","  var msg = (this.negate ? negateMsg : msg)","    , ok = this.negate ? !expr : expr;","","  if (!ok) {","    throw new AssertionError({","        message: this.msg ? this.msg + ': ' + msg : msg // include custom message if available","      , actual: actual","      , expected: expected","      , stackStartFunction: (Assertion.includeStack) ? this.assert : this.ssfi","    });","  }","};","","/*!"," * # inspect"," *"," * Returns the current object stringified."," *"," * @name inspect"," * @api private"," */","","Object.defineProperty(Assertion.prototype, 'inspect',","  { get: function () {","      return inspect(this.obj);","    }","  , configurable: true","});","","/**"," * # to"," *"," * Language chain."," *"," * @name to"," * @api public"," */","","Object.defineProperty(Assertion.prototype, 'to',","  { get: function () {","      return this;","    }","  , configurable: true","});","","/**"," * # be"," *"," * Language chain."," *"," * @name be"," * @api public"," */","","Object.defineProperty(Assertion.prototype, 'be',","  { get: function () {","      return this;","    }","  , configurable: true","});","","/**"," * # been"," *"," * Language chain. Also tests `tense` to past for addon"," * modules that use the tense feature."," *"," * @name been"," * @api public"," */","","Object.defineProperty(Assertion.prototype, 'been',","  { get: function () {","      this.tense = 'past';","      return this;","    }","  , configurable: true","});","","/**"," * # an"," *"," * Language chain."," *"," * @name an"," * @api public"," */","","Object.defineProperty(Assertion.prototype, 'an',","  { get: function () {","      return this;","    }","  , configurable: true","});","/**"," * # is"," *"," * Language chain."," *"," * @name is"," * @api public"," */","","Object.defineProperty(Assertion.prototype, 'is',","  { get: function () {","      return this;","    }","  , configurable: true","});","","/**"," * # and"," *"," * Language chain."," *"," * @name and"," * @api public"," */","","Object.defineProperty(Assertion.prototype, 'and',","  { get: function () {","      return this;","    }","  , configurable: true","});","","/**"," * # have"," *"," * Language chain."," *"," * @name have"," * @api public"," */","","Object.defineProperty(Assertion.prototype, 'have',","  { get: function () {","      return this;","    }","  , configurable: true","});","","/**"," * # with"," *"," * Language chain."," *"," * @name with"," * @api public"," */","","Object.defineProperty(Assertion.prototype, 'with',","  { get: function () {","      return this;","    }","  , configurable: true","});","","/**"," * # .not"," *"," * Negates any of assertions following in the chain."," *"," * @name not"," * @api public"," */","","Object.defineProperty(Assertion.prototype, 'not',","  { get: function () {","      this.negate = true;","      return this;","    }","  , configurable: true","});","","/**"," * # .ok"," *"," * Assert object truthiness."," *"," *      expect('everthing').to.be.ok;"," *      expect(false).to.not.be.ok;"," *      expect(undefined).to.not.be.ok;"," *      expect(null).to.not.be.ok;"," *"," * @name ok"," * @api public"," */","","Object.defineProperty(Assertion.prototype, 'ok',","  { get: function () {","      this.assert(","          this.obj","        , 'expected ' + this.inspect + ' to be truthy'","        , 'expected ' + this.inspect + ' to be falsy');","","      return this;","    }","  , configurable: true","});","","/**"," * # .true"," *"," * Assert object is true"," *"," * @name true"," * @api public"," */","","Object.defineProperty(Assertion.prototype, 'true',","  { get: function () {","      this.assert(","          true === this.obj","        , 'expected ' + this.inspect + ' to be true'","        , 'expected ' + this.inspect + ' to be false'","        , this.negate ? false : true","      );","","      return this;","    }","  , configurable: true","});","","/**"," * # .false"," *"," * Assert object is false"," *"," * @name false"," * @api public"," */","","Object.defineProperty(Assertion.prototype, 'false',","  { get: function () {","      this.assert(","          false === this.obj","        , 'expected ' + this.inspect + ' to be false'","        , 'expected ' + this.inspect + ' to be true'","        , this.negate ? true : false","      );","","      return this;","    }","  , configurable: true","});","","/**"," * # .exist"," *"," * Assert object exists (null)."," *"," *      var foo = 'hi'"," *        , bar;"," *      expect(foo).to.exist;"," *      expect(bar).to.not.exist;"," *"," * @name exist"," * @api public"," */","","Object.defineProperty(Assertion.prototype, 'exist',","  { get: function () {","      this.assert(","          null != this.obj","        , 'expected ' + this.inspect + ' to exist'","        , 'expected ' + this.inspect + ' to not exist'","      );","","      return this;","    }","  , configurable: true","});","","/**"," * # .empty"," *"," * Assert object's length to be 0."," *"," *      expect([]).to.be.empty;"," *"," * @name empty"," * @api public"," */","","Object.defineProperty(Assertion.prototype, 'empty',","  { get: function () {","      var expected = this.obj;","","      if (Array.isArray(this.obj)) {","        expected = this.obj.length;","      } else if (typeof this.obj === 'object') {","        expected = Object.keys(this.obj).length;","      }","","      this.assert(","          !expected","        , 'expected ' + this.inspect + ' to be empty'","        , 'expected ' + this.inspect + ' not to be empty');","","      return this;","    }","  , configurable: true","});","","/**"," * # .arguments"," *"," * Assert object is an instanceof arguments."," *"," *      function test () {"," *        expect(arguments).to.be.arguments;"," *      }"," *"," * @name arguments"," * @api public"," */","","Object.defineProperty(Assertion.prototype, 'arguments',","  { get: function () {","      this.assert(","          '[object Arguments]' == Object.prototype.toString.call(this.obj)","        , 'expected ' + this.inspect + ' to be arguments'","        , 'expected ' + this.inspect + ' to not be arguments'","        , '[object Arguments]'","        , Object.prototype.toString.call(this.obj)","      );","","      return this;","    }","  , configurable: true","});","","/**"," * # .equal(value)"," *"," * Assert strict equality."," *"," *      expect('hello').to.equal('hello');"," *"," * @name equal"," * @param {*} value"," * @api public"," */","","Assertion.prototype.equal = function (val) {","  this.assert(","      val === this.obj","    , 'expected ' + this.inspect + ' to equal ' + inspect(val)","    , 'expected ' + this.inspect + ' to not equal ' + inspect(val)","    , val );","","  return this;","};","","/**"," * # .eql(value)"," *"," * Assert deep equality."," *"," *      expect({ foo: 'bar' }).to.eql({ foo: 'bar' });"," *"," * @name eql"," * @param {*} value"," * @api public"," */","","Assertion.prototype.eql = function (obj) {","  this.assert(","      eql(obj, this.obj)","    , 'expected ' + this.inspect + ' to equal ' + inspect(obj)","    , 'expected ' + this.inspect + ' to not equal ' + inspect(obj)","    , obj );","","  return this;","};","","/**"," * # .above(value)"," *"," * Assert greater than `value`."," *"," *      expect(10).to.be.above(5);"," *"," * @name above"," * @param {Number} value"," * @api public"," */","","Assertion.prototype.above = function (val) {","  this.assert(","      this.obj &gt; val","    , 'expected ' + this.inspect + ' to be above ' + val","    , 'expected ' + this.inspect + ' to be below ' + val);","","  return this;","};","","/**"," * # .below(value)"," *"," * Assert less than `value`."," *"," *      expect(5).to.be.below(10);"," *"," * @name below"," * @param {Number} value"," * @api public"," */","","Assertion.prototype.below = function (val) {","  this.assert(","      this.obj &lt; val","    , 'expected ' + this.inspect + ' to be below ' + val","    , 'expected ' + this.inspect + ' to be above ' + val);","","  return this;","};","","/**"," * # .within(start, finish)"," *"," * Assert that a number is within a range."," *"," *      expect(7).to.be.within(5,10);"," *"," * @name within"," * @param {Number} start lowerbound inclusive"," * @param {Number} finish upperbound inclusive"," * @api public"," */","","Assertion.prototype.within = function (start, finish) {","  var range = start + '..' + finish;","","  this.assert(","      this.obj &gt;= start &amp;&amp; this.obj &lt;= finish","    , 'expected ' + this.inspect + ' to be within ' + range","    , 'expected ' + this.inspect + ' to not be within ' + range);","","  return this;","};","","/**"," * # .a(type)"," *"," * Assert typeof."," *"," *      expect('test').to.be.a('string');"," *"," * @name a"," * @param {String} type"," * @api public"," */","","Assertion.prototype.a = function (type) {","  var klass = type.charAt(0).toUpperCase() + type.slice(1);","","  this.assert(","      '[object ' + klass + ']' === toString.call(this.obj)","    , 'expected ' + this.inspect + ' to be a ' + type","    , 'expected ' + this.inspect + ' not to be a ' + type","    , '[object ' + klass + ']'","    , toString.call(this.obj)","  );","","  return this;","};","","/**"," * # .instanceof(constructor)"," *"," * Assert instanceof."," *"," *      var Tea = function (name) { this.name = name; }"," *        , Chai = new Tea('chai');"," *"," *      expect(Chai).to.be.an.instanceOf(Tea);"," *"," * @name instanceof"," * @param {Constructor}"," * @alias instanceOf"," * @api public"," */","","Assertion.prototype.instanceof = function (constructor) {","  var name = constructor.name;","  this.assert(","      this.obj instanceof constructor","    , 'expected ' + this.inspect + ' to be an instance of ' + name","    , 'expected ' + this.inspect + ' to not be an instance of ' + name);","","  return this;","};","","/**"," * # .property(name, [value])"," *"," * Assert that property of `name` exists, optionally with `value`."," *"," *      var obj = { foo: 'bar' }"," *      expect(obj).to.have.property('foo');"," *      expect(obj).to.have.property('foo', 'bar');"," *      expect(obj).to.have.property('foo').to.be.a('string');"," *"," * @name property"," * @param {String} name"," * @param {*} value (optional)"," * @returns value of property for chaining"," * @api public"," */","","Assertion.prototype.property = function (name, val) {","  if (this.negate &amp;&amp; undefined !== val) {","    if (undefined === this.obj[name]) {","      throw new Error(this.inspect + ' has no property ' + inspect(name));","    }","  } else {","    this.assert(","        undefined !== this.obj[name]","      , 'expected ' + this.inspect + ' to have a property ' + inspect(name)","      , 'expected ' + this.inspect + ' to not have property ' + inspect(name));","  }","","  if (undefined !== val) {","    this.assert(","        val === this.obj[name]","      , 'expected ' + this.inspect + ' to have a property ' + inspect(name) + ' of ' +","          inspect(val) + ', but got ' + inspect(this.obj[name])","      , 'expected ' + this.inspect + ' to not have a property ' + inspect(name) + ' of ' +  inspect(val)","      , val","      , this.obj[val]","    );","  }","","  this.obj = this.obj[name];","  return this;","};","","/**"," * # .ownProperty(name)"," *"," * Assert that has own property by `name`."," *"," *      expect('test').to.have.ownProperty('length');"," *"," * @name ownProperty"," * @alias haveOwnProperty"," * @param {String} name"," * @api public"," */","","Assertion.prototype.ownProperty = function (name) {","  this.assert(","      this.obj.hasOwnProperty(name)","    , 'expected ' + this.inspect + ' to have own property ' + inspect(name)","    , 'expected ' + this.inspect + ' to not have own property ' + inspect(name));","  return this;","};","","/**"," * # .length(val)"," *"," * Assert that object has expected length."," *"," *      expect([1,2,3]).to.have.length(3);"," *      expect('foobar').to.have.length(6);"," *"," * @name length"," * @alias lengthOf"," * @param {Number} length"," * @api public"," */","","Assertion.prototype.length = function (n) {","  new Assertion(this.obj).to.have.property('length');","  var len = this.obj.length;","","  this.assert(","      len == n","    , 'expected ' + this.inspect + ' to have a length of ' + n + ' but got ' + len","    , 'expected ' + this.inspect + ' to not have a length of ' + len","    , n","    , len","  );","","  return this;","};","","/**"," * # .match(regexp)"," *"," * Assert that matches regular expression."," *"," *      expect('foobar').to.match(/^foo/);"," *"," * @name match"," * @param {RegExp} RegularExpression"," * @api public"," */","","Assertion.prototype.match = function (re) {","  this.assert(","      re.exec(this.obj)","    , 'expected ' + this.inspect + ' to match ' + re","    , 'expected ' + this.inspect + ' not to match ' + re);","","  return this;","};","","/**"," * # .include(obj)"," *"," * Assert the inclusion of an object in an Array or substring in string."," *"," *      expect([1,2,3]).to.include(2);"," *"," * @name include"," * @param {Object|String|Number} obj"," * @api public"," */","","Assertion.prototype.include = function (obj) {","  this.assert(","      ~this.obj.indexOf(obj)","    , 'expected ' + this.inspect + ' to include ' + inspect(obj)","    , 'expected ' + this.inspect + ' to not include ' + inspect(obj));","","  return this;","};","","/**"," * # .string(string)"," *"," * Assert inclusion of string in string."," *"," *      expect('foobar').to.have.string('bar');"," *"," * @name string"," * @param {String} string"," * @api public"," */","","Assertion.prototype.string = function (str) {","  new Assertion(this.obj).is.a('string');","","  this.assert(","      ~this.obj.indexOf(str)","    , 'expected ' + this.inspect + ' to contain ' + inspect(str)","    , 'expected ' + this.inspect + ' to not contain ' + inspect(str));","","  return this;","};","","","","/**"," * # contain"," *"," * Toggles the `contain` flag for the `keys` assertion."," *"," * @name contain"," * @api public"," */","","Object.defineProperty(Assertion.prototype, 'contain',","  { get: function () {","      this.contains = true;","      return this;","    },","    configurable: true","});","","/**"," * # .keys(key1, [key2], [...])"," *"," * Assert exact keys or the inclusing of keys using the `contain` modifier."," *"," *      expect({ foo: 1, bar: 2 }).to.have.keys(['foo', 'bar']);"," *      expect({ foo: 1, bar: 2, baz: 3 }).to.contain.keys('foo', 'bar');"," *"," * @name keys"," * @alias key"," * @param {String|Array} Keys"," * @api public"," */","","Assertion.prototype.keys = function(keys) {","  var str","    , ok = true;","","  keys = keys instanceof Array","    ? keys","    : Array.prototype.slice.call(arguments);","","  if (!keys.length) throw new Error('keys required');","","  var actual = Object.keys(this.obj)","    , len = keys.length;","","  // Inclusion","  ok = keys.every(function(key){","    return ~actual.indexOf(key);","  });","","  // Strict","  if (!this.negate &amp;&amp; !this.contains) {","    ok = ok &amp;&amp; keys.length == actual.length;","  }","","  // Key string","  if (len &gt; 1) {","    keys = keys.map(function(key){","      return inspect(key);","    });","    var last = keys.pop();","    str = keys.join(', ') + ', and ' + last;","  } else {","    str = inspect(keys[0]);","  }","","  // Form","  str = (len &gt; 1 ? 'keys ' : 'key ') + str;","","  // Have / include","  str = (this.contains ? 'contain ' : 'have ') + str;","","  // Assertion","  this.assert(","      ok","    , 'expected ' + this.inspect + ' to ' + str","    , 'expected ' + this.inspect + ' to not ' + str","    , keys","    , Object.keys(this.obj)","  );","","  return this;","}","","/**"," * # .throw(constructor)"," *"," * Assert that a function will throw a specific type of error or that error"," * thrown will match a RegExp or include a string."," *"," *      var fn = function () { throw new ReferenceError('This is a bad function.'); }"," *      expect(fn).to.throw(ReferenceError);"," *      expect(fn).to.throw(/bad function/);"," *      expect(fn).to.not.throw('good function');"," *      expect(fn).to.throw(ReferenceError, /bad function/);"," *"," * Please note that when a throw expectation is negated, it will check each"," * parameter independently, starting with Error constructor type. The appropriate way"," * to check for the existence of a type of error but for a message that does not match"," * is to use `and`."," *"," *      expect(fn).to.throw(ReferenceError).and.not.throw(/good function/);"," *"," * @name throw"," * @alias throws"," * @alias Throw"," * @param {ErrorConstructor} constructor"," * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types"," * @api public"," */","","Assertion.prototype.throw = function (constructor, msg) {","  new Assertion(this.obj).is.a('function');","","  var thrown = false;","","  if (arguments.length === 0) {","    msg = null;","    constructor = null;","  } else if (constructor &amp;&amp; (constructor instanceof RegExp || 'string' === typeof constructor)) {","    msg = constructor;","    constructor = null;","  }","","  try {","    this.obj();","  } catch (err) {","    // first, check constructor","    if (constructor &amp;&amp; 'function' === typeof constructor) {","      this.assert(","          err instanceof constructor &amp;&amp; err.name == constructor.name","        , 'expected ' + this.inspect + ' to throw ' + constructor.name + ' but a ' + err.name + ' was thrown'","        , 'expected ' + this.inspect + ' to not throw ' + constructor.name );","      if (!msg) return this;","    }","    // next, check message","    if (err.message &amp;&amp; msg &amp;&amp; msg instanceof RegExp) {","      this.assert(","          msg.exec(err.message)","        , 'expected ' + this.inspect + ' to throw error matching ' + msg + ' but got ' + inspect(err.message)","        , 'expected ' + this.inspect + ' to throw error not matching ' + msg","      );","      return this;","    } else if (err.message &amp;&amp; msg &amp;&amp; 'string' === typeof msg) {","      this.assert(","          ~err.message.indexOf(msg)","        , 'expected ' + this.inspect + ' to throw error including ' + inspect(msg) + ' but got ' + inspect(err.message)","        , 'expected ' + this.inspect + ' to throw error not including ' + inspect(msg)","      );","      return this;","    } else {","      thrown = true;","    }","  }","","  var name = (constructor ? constructor.name : 'an error');","","  this.assert(","      thrown === true","    , 'expected ' + this.inspect + ' to throw ' + name","    , 'expected ' + this.inspect + ' to not throw ' + name);","","  return this;","};","","/**"," * # .respondTo(method)"," *"," * Assert that object/class will respond to a method."," *"," *      expect(Klass).to.respondTo('bar');"," *      expect(obj).to.respondTo('bar');"," *"," * @name respondTo"," * @param {String} method"," * @api public"," */","","Assertion.prototype.respondTo = function (method) {","  var context = ('function' === typeof this.obj)","    ? this.obj.prototype[method]","    : this.obj[method];","","  this.assert(","      'function' === typeof context","    , 'expected ' + this.inspect + ' to respond to ' + inspect(method)","    , 'expected ' + this.inspect + ' to not respond to ' + inspect(method)","    , 'function'","    , typeof context","  );","","  return this;","};","","/**"," * # .satisfy(method)"," *"," * Assert that passes a truth test."," *"," *      expect(1).to.satisfy(function(num) { return num &gt; 0; });"," *"," * @name satisfy"," * @param {Function} matcher"," * @api public"," */","","Assertion.prototype.satisfy = function (matcher) {","  this.assert(","      matcher(this.obj)","    , 'expected ' + this.inspect + ' to satisfy ' + inspect(matcher)","    , 'expected ' + this.inspect + ' to not satisfy' + inspect(matcher)","    , this.negate ? false : true","    , matcher(this.obj)","  );","","  return this;","};","","/**"," * # .closeTo(expected, delta)"," *"," * Assert that actual is equal to +/- delta."," *"," *      expect(1.5).to.be.closeTo(1, 0.5);"," *"," * @name closeTo"," * @param {Number} expected"," * @param {Number} delta"," * @api public"," */","","Assertion.prototype.closeTo = function (expected, delta) {","  this.assert(","      (this.obj - delta === expected) || (this.obj + delta === expected)","    , 'expected ' + this.inspect + ' to be close to ' + expected + ' +/- ' + delta","    , 'expected ' + this.inspect + ' not to be close to ' + expected + ' +/- ' + delta);","","  return this;","};","","/*!"," * Aliases."," */","","(function alias(name, as){","  Assertion.prototype[as] = Assertion.prototype[name];","  return alias;","})","('length', 'lengthOf')","('keys', 'key')","('ownProperty', 'haveOwnProperty')","('above', 'greaterThan')","('below', 'lessThan')","('throw', 'throws')","('throw', 'Throw') // for troublesome browsers","('instanceof', 'instanceOf');"];
